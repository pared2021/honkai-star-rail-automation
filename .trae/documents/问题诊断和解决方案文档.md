# xingtieé¡¹ç›®é—®é¢˜è¯Šæ–­å’Œè§£å†³æ–¹æ¡ˆæ–‡æ¡£

## 1. é—®é¢˜æ¦‚è¿°

**é¡¹ç›®çŠ¶æ€**: ğŸ”´ åŠŸèƒ½æ— å®é™…ä½œç”¨  
**è¯Šæ–­æ—¶é—´**: 2025-01-06  
**é—®é¢˜ä¸¥é‡ç¨‹åº¦**: é«˜  
**å½±å“èŒƒå›´**: æ•´ä¸ªé¡¹ç›®çš„æ ¸å¿ƒåŠŸèƒ½  

### 1.1 é—®é¢˜æè¿°

xingtieé¡¹ç›®è™½ç„¶å…·å¤‡å®Œæ•´çš„æ¶æ„è®¾è®¡å’Œä»£ç ç»“æ„ï¼Œä½†åœ¨å®é™…è¿è¡Œä¸­å‘ç°æ ¸å¿ƒåŠŸèƒ½æ— æ³•æ­£å¸¸å·¥ä½œï¼Œä¸»è¦è¡¨ç°ä¸ºï¼š

- è‡ªåŠ¨åŒ–åŠŸèƒ½å¯åŠ¨å¤±è´¥
- æ¸¸æˆæ£€æµ‹åŠŸèƒ½æ— æ³•æ­£å¸¸å·¥ä½œ
- ä»»åŠ¡ç®¡ç†ç³»ç»Ÿå­˜åœ¨æ¥å£ä¸åŒ¹é…é—®é¢˜
- ç›‘æ§ç³»ç»ŸæŒç»­æŠ¥å‘Šå¥åº·æ£€æŸ¥å¤±è´¥
- ç”¨æˆ·ç•Œé¢è™½ç„¶å¯ä»¥æ˜¾ç¤ºï¼Œä½†æ ¸å¿ƒä¸šåŠ¡é€»è¾‘ç¼ºå¤±

### 1.2 ç—‡çŠ¶è¡¨ç°

æ ¹æ®é¡¹ç›®è´¨é‡æŠ¥å‘Šå’Œè¿è¡Œæ—¥å¿—åˆ†æï¼Œä¸»è¦ç—‡çŠ¶åŒ…æ‹¬ï¼š

1. **å¥åº·æ£€æŸ¥æŒç»­å¤±è´¥**
   - `game_detector` æ¨¡å—æ£€æŸ¥å¤±è´¥
   - `task_manager` æ¨¡å—æ£€æŸ¥å¤±è´¥
   - æ€»è€—æ—¶çº¦1.03-1.04ç§’ï¼Œä½†åŠŸèƒ½æœªæ­£å¸¸å¯åŠ¨

2. **æ¥å£è°ƒç”¨é”™è¯¯**
   - `TaskManager`å¯¹è±¡ç¼ºå°‘`start_concurrent_manager`å±æ€§
   - `MetricsCollector`å¯¹è±¡ç¼ºå°‘`record_gauge`å±æ€§
   - `AutomationController`å¯¹è±¡ç¼ºå°‘`get_available_tasks`å±æ€§

3. **ä¸šåŠ¡é€»è¾‘ç©ºæ´**
   - è‡ªåŠ¨åŒ–æ§åˆ¶å™¨å¯åŠ¨åæ— å®é™…æ“ä½œ
   - æ¸¸æˆæ£€æµ‹åŠŸèƒ½è™½æœ‰æ¡†æ¶ä½†ç¼ºä¹å®é™…æ£€æµ‹é€»è¾‘
   - ä»»åŠ¡æ‰§è¡Œå™¨æ— å…·ä½“çš„ä»»åŠ¡å®ç°

## 2. æ ¹æœ¬åŸå› åˆ†æ

### 2.1 æ¶æ„å±‚é¢é—®é¢˜

#### 2.1.1 æ¥å£å®šä¹‰ä¸å®ç°ä¸åŒ¹é…

**é—®é¢˜**: ä»£ç ä¸­å®šä¹‰çš„æ¥å£ä¸å®é™…å®ç°å­˜åœ¨ä¸¥é‡ä¸åŒ¹é…

**å…·ä½“è¡¨ç°**:
```python
# è°ƒç”¨ä»£ç æœŸæœ›çš„æ¥å£
automation_controller.start_concurrent_manager()  # æ–¹æ³•ä¸å­˜åœ¨
metrics_collector.record_gauge("health_check", 1)  # æ–¹æ³•ä¸å­˜åœ¨
tasks = automation_controller.get_available_tasks()  # æ–¹æ³•ä¸å­˜åœ¨
```

**æ ¹æœ¬åŸå› **: 
- æ¥å£è®¾è®¡ä¸å®ç°åˆ†ç¦»ï¼Œç¼ºä¹ç»Ÿä¸€çš„æ¥å£è§„èŒƒ
- ä»£ç å¼€å‘è¿‡ç¨‹ä¸­æ¥å£å˜æ›´æœªåŒæ­¥æ›´æ–°
- ç¼ºä¹æ¥å£å…¼å®¹æ€§æµ‹è¯•

#### 2.1.2 ä¾èµ–æ³¨å…¥é…ç½®ä¸å®Œæ•´

**é—®é¢˜**: ä¾èµ–æ³¨å…¥å®¹å™¨é…ç½®ä¸å®Œæ•´ï¼Œå¯¼è‡´æœåŠ¡å®ä¾‹åŒ–å¤±è´¥

**å…·ä½“è¡¨ç°**:
- æœåŠ¡å®¹å™¨ä¸­æ³¨å†Œçš„æœåŠ¡ä¸å®é™…éœ€è¦çš„æœåŠ¡ä¸åŒ¹é…
- å¾ªç¯ä¾èµ–é—®é¢˜æœªè§£å†³
- æœåŠ¡ç”Ÿå‘½å‘¨æœŸç®¡ç†ä¸å½“

### 2.2 å®ç°å±‚é¢é—®é¢˜

#### 2.2.1 æ ¸å¿ƒä¸šåŠ¡é€»è¾‘ç¼ºå¤±

**é—®é¢˜**: è™½ç„¶æœ‰å®Œæ•´çš„ç±»ç»“æ„ï¼Œä½†æ ¸å¿ƒä¸šåŠ¡é€»è¾‘å®ç°ä¸ºç©ºæˆ–ä»…æœ‰å ä½ç¬¦

**å…·ä½“åˆ†æ**:

1. **GameDetectorå®ç°ä¸å®Œæ•´**
```python
# å½“å‰å®ç°
class GameDetector:
    def detect_game_window(self):
        # ä»…æœ‰åŸºç¡€æ¡†æ¶ï¼Œç¼ºä¹å®é™…çš„æ¸¸æˆçª—å£æ£€æµ‹é€»è¾‘
        pass
    
    def is_game_running(self):
        # è¿”å›å›ºå®šå€¼æˆ–ç®€å•åˆ¤æ–­ï¼Œæ— å®é™…æ£€æµ‹
        return False
```

**ç¼ºå¤±çš„åŠŸèƒ½**:
- å®é™…çš„æ¸¸æˆè¿›ç¨‹æ£€æµ‹
- æ¸¸æˆçª—å£è¯†åˆ«å’Œå®šä½
- æ¸¸æˆçŠ¶æ€åˆ¤æ–­é€»è¾‘
- åœºæ™¯è¯†åˆ«å’ŒUIå…ƒç´ å®šä½

2. **TaskManageråŠŸèƒ½ç©ºæ´**
```python
# å½“å‰å®ç°
class TaskManager:
    def start_task(self, task_id):
        # ä»…æ›´æ–°çŠ¶æ€ï¼Œæ— å®é™…ä»»åŠ¡æ‰§è¡Œé€»è¾‘
        self.tasks[task_id].status = "running"
    
    def execute_task(self, task_id):
        # ç©ºå®ç°æˆ–ç®€å•çš„çŠ¶æ€å˜æ›´
        pass
```

**ç¼ºå¤±çš„åŠŸèƒ½**:
- å…·ä½“çš„ä»»åŠ¡æ‰§è¡Œé€»è¾‘
- ä»»åŠ¡è°ƒåº¦ç®—æ³•
- ä»»åŠ¡ä¾èµ–ç®¡ç†
- é”™è¯¯å¤„ç†å’Œé‡è¯•æœºåˆ¶

3. **AutomationControllerç¼ºä¹è‡ªåŠ¨åŒ–é€»è¾‘**
```python
# å½“å‰å®ç°
class AutomationController:
    def start_automation(self):
        # ä»…å¯åŠ¨åŸºç¡€æœåŠ¡ï¼Œæ— å®é™…è‡ªåŠ¨åŒ–æ“ä½œ
        self.is_running = True
    
    def process_automation(self):
        # ç©ºçš„å¤„ç†å¾ªç¯
        while self.is_running:
            time.sleep(1)  # ä»…ç­‰å¾…ï¼Œæ— å®é™…æ“ä½œ
```

**ç¼ºå¤±çš„åŠŸèƒ½**:
- æ¸¸æˆè‡ªåŠ¨åŒ–è„šæœ¬æ‰§è¡Œ
- åŸºäºæ¸¸æˆçŠ¶æ€çš„å†³ç­–é€»è¾‘
- ç”¨æˆ·é…ç½®çš„ä»»åŠ¡æ‰§è¡Œ
- å¼‚å¸¸æƒ…å†µå¤„ç†

#### 2.2.2 ç›‘æ§ç³»ç»Ÿå®ç°ä¸å®Œæ•´

**é—®é¢˜**: ç›‘æ§ç³»ç»Ÿè™½æœ‰æ¡†æ¶ä½†ç¼ºä¹å®é™…çš„ç›‘æ§é€»è¾‘

**å…·ä½“è¡¨ç°**:
- HealthCheckeråªæ£€æŸ¥æœåŠ¡æ˜¯å¦å­˜åœ¨ï¼Œä¸æ£€æŸ¥åŠŸèƒ½æ˜¯å¦æ­£å¸¸
- MetricsCollectorç¼ºå°‘å®é™…çš„æŒ‡æ ‡æ”¶é›†é€»è¾‘
- å‘Šè­¦æœºåˆ¶æœªå®ç°

### 2.3 é…ç½®å’Œæ•°æ®é—®é¢˜

#### 2.3.1 é…ç½®ç®¡ç†ä¸å®Œå–„

**é—®é¢˜**: é…ç½®æ–‡ä»¶ç»“æ„ä¸å®Œæ•´ï¼Œç¼ºå°‘å…³é”®é…ç½®é¡¹

**ç¼ºå¤±é…ç½®**:
- æ¸¸æˆæ£€æµ‹ç›¸å…³é…ç½®ï¼ˆçª—å£æ ‡é¢˜ã€è¿›ç¨‹åç­‰ï¼‰
- ä»»åŠ¡æ‰§è¡Œé…ç½®ï¼ˆæ‰§è¡Œé—´éš”ã€é‡è¯•æ¬¡æ•°ç­‰ï¼‰
- è‡ªåŠ¨åŒ–è„šæœ¬é…ç½®ï¼ˆæ“ä½œåºåˆ—ã€ç­‰å¾…æ—¶é—´ç­‰ï¼‰

#### 2.3.2 æ•°æ®æ¨¡å‹ä¸å®Œæ•´

**é—®é¢˜**: æ•°æ®åº“è¡¨ç»“æ„å’Œæ•°æ®æ¨¡å‹å®šä¹‰ä¸å®Œæ•´

**ç¼ºå¤±å†…å®¹**:
- ä»»åŠ¡æ‰§è¡Œå†å²è®°å½•
- æ¸¸æˆçŠ¶æ€å˜æ›´æ—¥å¿—
- ç”¨æˆ·æ“ä½œå®¡è®¡æ—¥å¿—
- æ€§èƒ½ç›‘æ§æ•°æ®

## 3. è¯¦ç»†è§£å†³æ–¹æ¡ˆ

### 3.1 æ¥å£è§„èŒƒåŒ–è§£å†³æ–¹æ¡ˆ

#### 3.1.1 ç»Ÿä¸€æ¥å£å®šä¹‰

**ç›®æ ‡**: å»ºç«‹ç»Ÿä¸€çš„æ¥å£è§„èŒƒï¼Œç¡®ä¿æ¥å£å®šä¹‰ä¸å®ç°ä¸€è‡´

**å®æ–½æ­¥éª¤**:

1. **åˆ›å»ºæ¥å£å®šä¹‰æ–‡ä»¶**
```python
# src/interfaces/automation_interface.py
from abc import ABC, abstractmethod
from typing import List, Optional

class IAutomationController(ABC):
    @abstractmethod
    def start_automation(self) -> bool:
        """å¯åŠ¨è‡ªåŠ¨åŒ–"""
        pass
    
    @abstractmethod
    def stop_automation(self) -> bool:
        """åœæ­¢è‡ªåŠ¨åŒ–"""
        pass
    
    @abstractmethod
    def get_automation_status(self) -> str:
        """è·å–è‡ªåŠ¨åŒ–çŠ¶æ€"""
        pass
    
    @abstractmethod
    def get_available_tasks(self) -> List[str]:
        """è·å–å¯ç”¨ä»»åŠ¡åˆ—è¡¨"""
        pass

class IGameDetector(ABC):
    @abstractmethod
    def detect_game_window(self) -> Optional[dict]:
        """æ£€æµ‹æ¸¸æˆçª—å£"""
        pass
    
    @abstractmethod
    def is_game_running(self) -> bool:
        """æ£€æŸ¥æ¸¸æˆæ˜¯å¦è¿è¡Œ"""
        pass
    
    @abstractmethod
    def capture_screen(self) -> Optional[bytes]:
        """æˆªå–æ¸¸æˆç”»é¢"""
        pass

class ITaskManager(ABC):
    @abstractmethod
    def create_task(self, task_config: dict) -> str:
        """åˆ›å»ºä»»åŠ¡"""
        pass
    
    @abstractmethod
    def start_task(self, task_id: str) -> bool:
        """å¯åŠ¨ä»»åŠ¡"""
        pass
    
    @abstractmethod
    def stop_task(self, task_id: str) -> bool:
        """åœæ­¢ä»»åŠ¡"""
        pass
    
    @abstractmethod
    def get_task_status(self, task_id: str) -> str:
        """è·å–ä»»åŠ¡çŠ¶æ€"""
        pass
```

2. **æ›´æ–°å®ç°ç±»ä»¥ç¬¦åˆæ¥å£**
```python
# src/core/automation_controller.py
from src.interfaces.automation_interface import IAutomationController

class AutomationController(IAutomationController):
    def __init__(self):
        self.is_running = False
        self.available_tasks = []
        self.game_detector = None
        self.task_manager = None
    
    def start_automation(self) -> bool:
        """å¯åŠ¨è‡ªåŠ¨åŒ–"""
        try:
            # æ£€æŸ¥æ¸¸æˆæ˜¯å¦è¿è¡Œ
            if not self.game_detector.is_game_running():
                return False
            
            self.is_running = True
            # å¯åŠ¨è‡ªåŠ¨åŒ–å¾ªç¯
            self._start_automation_loop()
            return True
        except Exception as e:
            logger.error(f"å¯åŠ¨è‡ªåŠ¨åŒ–å¤±è´¥: {e}")
            return False
    
    def stop_automation(self) -> bool:
        """åœæ­¢è‡ªåŠ¨åŒ–"""
        self.is_running = False
        return True
    
    def get_automation_status(self) -> str:
        """è·å–è‡ªåŠ¨åŒ–çŠ¶æ€"""
        return "running" if self.is_running else "stopped"
    
    def get_available_tasks(self) -> List[str]:
        """è·å–å¯ç”¨ä»»åŠ¡åˆ—è¡¨"""
        return self.available_tasks.copy()
    
    def _start_automation_loop(self):
        """å¯åŠ¨è‡ªåŠ¨åŒ–å¾ªç¯"""
        # å®é™…çš„è‡ªåŠ¨åŒ–é€»è¾‘å°†åœ¨åç»­å®ç°
        pass
```

#### 3.1.2 æ¥å£å…¼å®¹æ€§æµ‹è¯•

**ç›®æ ‡**: ç¡®ä¿æ‰€æœ‰æ¥å£è°ƒç”¨éƒ½æœ‰å¯¹åº”çš„å®ç°

**å®æ–½æ–¹æ¡ˆ**:
```python
# tests/test_interface_compatibility.py
import pytest
from src.interfaces.automation_interface import IAutomationController, IGameDetector, ITaskManager
from src.core.automation_controller import AutomationController
from src.core.game_detector import GameDetector
from src.core.task_manager import TaskManager

class TestInterfaceCompatibility:
    def test_automation_controller_interface(self):
        """æµ‹è¯•AutomationControlleræ¥å£å…¼å®¹æ€§"""
        controller = AutomationController()
        assert isinstance(controller, IAutomationController)
        
        # æµ‹è¯•æ‰€æœ‰æ¥å£æ–¹æ³•æ˜¯å¦å­˜åœ¨
        assert hasattr(controller, 'start_automation')
        assert hasattr(controller, 'stop_automation')
        assert hasattr(controller, 'get_automation_status')
        assert hasattr(controller, 'get_available_tasks')
    
    def test_game_detector_interface(self):
        """æµ‹è¯•GameDetectoræ¥å£å…¼å®¹æ€§"""
        detector = GameDetector()
        assert isinstance(detector, IGameDetector)
        
        # æµ‹è¯•æ‰€æœ‰æ¥å£æ–¹æ³•æ˜¯å¦å­˜åœ¨
        assert hasattr(detector, 'detect_game_window')
        assert hasattr(detector, 'is_game_running')
        assert hasattr(detector, 'capture_screen')
    
    def test_task_manager_interface(self):
        """æµ‹è¯•TaskManageræ¥å£å…¼å®¹æ€§"""
        manager = TaskManager()
        assert isinstance(manager, ITaskManager)
        
        # æµ‹è¯•æ‰€æœ‰æ¥å£æ–¹æ³•æ˜¯å¦å­˜åœ¨
        assert hasattr(manager, 'create_task')
        assert hasattr(manager, 'start_task')
        assert hasattr(manager, 'stop_task')
        assert hasattr(manager, 'get_task_status')
```

### 3.2 æ ¸å¿ƒåŠŸèƒ½å®ç°æ–¹æ¡ˆ

#### 3.2.1 GameDetectorå®Œæ•´å®ç°

**ç›®æ ‡**: å®ç°çœŸæ­£å¯ç”¨çš„æ¸¸æˆæ£€æµ‹åŠŸèƒ½

**å®æ–½æ–¹æ¡ˆ**:
```python
# src/core/game_detector.py
import cv2
import numpy as np
import win32gui
import win32con
import win32ui
from PIL import Image
from typing import Optional, Tuple, List
from src.interfaces.automation_interface import IGameDetector

class GameDetector(IGameDetector):
    def __init__(self):
        self.game_window_title = "å´©åï¼šæ˜Ÿç©¹é“é“"
        self.game_process_name = "StarRail.exe"
        self.current_window = None
        self.template_cache = {}
    
    def detect_game_window(self) -> Optional[dict]:
        """æ£€æµ‹æ¸¸æˆçª—å£"""
        def enum_windows_callback(hwnd, windows):
            if win32gui.IsWindowVisible(hwnd):
                window_title = win32gui.GetWindowText(hwnd)
                if self.game_window_title in window_title:
                    rect = win32gui.GetWindowRect(hwnd)
                    windows.append({
                        'handle': hwnd,
                        'title': window_title,
                        'rect': rect,
                        'width': rect[2] - rect[0],
                        'height': rect[3] - rect[1]
                    })
            return True
        
        windows = []
        win32gui.EnumWindows(enum_windows_callback, windows)
        
        if windows:
            self.current_window = windows[0]
            return self.current_window
        return None
    
    def is_game_running(self) -> bool:
        """æ£€æŸ¥æ¸¸æˆæ˜¯å¦è¿è¡Œ"""
        import psutil
        
        # æ£€æŸ¥è¿›ç¨‹
        for proc in psutil.process_iter(['pid', 'name']):
            try:
                if proc.info['name'] == self.game_process_name:
                    return True
            except (psutil.NoSuchProcess, psutil.AccessDenied):
                continue
        
        # æ£€æŸ¥çª—å£
        return self.detect_game_window() is not None
    
    def capture_screen(self) -> Optional[bytes]:
        """æˆªå–æ¸¸æˆç”»é¢"""
        if not self.current_window:
            if not self.detect_game_window():
                return None
        
        try:
            hwnd = self.current_window['handle']
            rect = self.current_window['rect']
            width = rect[2] - rect[0]
            height = rect[3] - rect[1]
            
            # è·å–çª—å£è®¾å¤‡ä¸Šä¸‹æ–‡
            hwndDC = win32gui.GetWindowDC(hwnd)
            mfcDC = win32ui.CreateDCFromHandle(hwndDC)
            saveDC = mfcDC.CreateCompatibleDC()
            
            # åˆ›å»ºä½å›¾å¯¹è±¡
            saveBitMap = win32ui.CreateBitmap()
            saveBitMap.CreateCompatibleBitmap(mfcDC, width, height)
            saveDC.SelectObject(saveBitMap)
            
            # æˆªå›¾
            result = windll.user32.PrintWindow(hwnd, saveDC.GetSafeHdc(), 3)
            
            if result:
                # è½¬æ¢ä¸ºPILå›¾åƒ
                bmpinfo = saveBitMap.GetInfo()
                bmpstr = saveBitMap.GetBitmapBits(True)
                
                img = Image.frombuffer(
                    'RGB',
                    (bmpinfo['bmWidth'], bmpinfo['bmHeight']),
                    bmpstr, 'raw', 'BGRX', 0, 1
                )
                
                # è½¬æ¢ä¸ºbytes
                import io
                img_bytes = io.BytesIO()
                img.save(img_bytes, format='PNG')
                return img_bytes.getvalue()
            
        except Exception as e:
            logger.error(f"æˆªå›¾å¤±è´¥: {e}")
        finally:
            # æ¸…ç†èµ„æº
            try:
                win32gui.DeleteObject(saveBitMap.GetHandle())
                saveDC.DeleteDC()
                mfcDC.DeleteDC()
                win32gui.ReleaseDC(hwnd, hwndDC)
            except:
                pass
        
        return None
    
    def find_template(self, template_path: str, threshold: float = 0.8) -> Optional[dict]:
        """æ¨¡æ¿åŒ¹é…æŸ¥æ‰¾UIå…ƒç´ """
        screenshot_bytes = self.capture_screen()
        if not screenshot_bytes:
            return None
        
        # è½¬æ¢æˆªå›¾ä¸ºOpenCVæ ¼å¼
        nparr = np.frombuffer(screenshot_bytes, np.uint8)
        screenshot = cv2.imdecode(nparr, cv2.IMREAD_COLOR)
        
        # åŠ è½½æ¨¡æ¿
        template = self._load_template(template_path)
        if template is None:
            return None
        
        # æ¨¡æ¿åŒ¹é…
        result = cv2.matchTemplate(screenshot, template, cv2.TM_CCOEFF_NORMED)
        min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)
        
        if max_val >= threshold:
            return {
                'template_path': template_path,
                'confidence': max_val,
                'location': max_loc,
                'size': template.shape[:2]
            }
        return None
    
    def _load_template(self, template_path: str) -> Optional[np.ndarray]:
        """åŠ è½½æ¨¡æ¿å›¾åƒ"""
        if template_path in self.template_cache:
            return self.template_cache[template_path]
        
        try:
            template = cv2.imread(template_path, cv2.IMREAD_COLOR)
            if template is not None:
                self.template_cache[template_path] = template
            return template
        except Exception as e:
            logger.error(f"åŠ è½½æ¨¡æ¿å¤±è´¥ {template_path}: {e}")
            return None
```

#### 3.2.2 TaskManagerå®Œæ•´å®ç°

**ç›®æ ‡**: å®ç°çœŸæ­£å¯ç”¨çš„ä»»åŠ¡ç®¡ç†åŠŸèƒ½

**å®æ–½æ–¹æ¡ˆ**:
```python
# src/core/task_manager.py
import asyncio
import uuid
from datetime import datetime
from typing import Dict, List, Optional, Callable
from enum import Enum
from dataclasses import dataclass, field
from src.interfaces.automation_interface import ITaskManager

class TaskStatus(Enum):
    CREATED = "created"
    RUNNING = "running"
    PAUSED = "paused"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"

class TaskType(Enum):
    DAILY_MISSION = "daily_mission"
    RESOURCE_FARMING = "resource_farming"
    BATTLE_PASS = "battle_pass"
    CUSTOM_SCRIPT = "custom_script"

@dataclass
class TaskConfig:
    name: str
    type: TaskType
    parameters: Dict = field(default_factory=dict)
    max_retries: int = 3
    timeout: int = 3600
    schedule: Optional[str] = None

@dataclass
class Task:
    id: str
    config: TaskConfig
    status: TaskStatus
    created_at: datetime
    started_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None
    error_message: Optional[str] = None
    retry_count: int = 0
    progress: float = 0.0

class TaskManager(ITaskManager):
    def __init__(self):
        self.tasks: Dict[str, Task] = {}
        self.running_tasks: Dict[str, asyncio.Task] = {}
        self.task_runners: Dict[TaskType, Callable] = {
            TaskType.DAILY_MISSION: self._run_daily_mission,
            TaskType.RESOURCE_FARMING: self._run_resource_farming,
            TaskType.BATTLE_PASS: self._run_battle_pass,
            TaskType.CUSTOM_SCRIPT: self._run_custom_script,
        }
        self.event_callbacks: List[Callable] = []
    
    def create_task(self, task_config: dict) -> str:
        """åˆ›å»ºä»»åŠ¡"""
        task_id = str(uuid.uuid4())
        
        config = TaskConfig(
            name=task_config.get('name', f'Task_{task_id[:8]}'),
            type=TaskType(task_config.get('type', 'custom_script')),
            parameters=task_config.get('parameters', {}),
            max_retries=task_config.get('max_retries', 3),
            timeout=task_config.get('timeout', 3600),
            schedule=task_config.get('schedule')
        )
        
        task = Task(
            id=task_id,
            config=config,
            status=TaskStatus.CREATED,
            created_at=datetime.now()
        )
        
        self.tasks[task_id] = task
        self._notify_task_event('task_created', task)
        return task_id
    
    def start_task(self, task_id: str) -> bool:
        """å¯åŠ¨ä»»åŠ¡"""
        task = self.tasks.get(task_id)
        if not task:
            return False
        
        if task.status != TaskStatus.CREATED:
            return False
        
        task.status = TaskStatus.RUNNING
        task.started_at = datetime.now()
        
        # åˆ›å»ºå¼‚æ­¥ä»»åŠ¡
        async_task = asyncio.create_task(self._execute_task(task))
        self.running_tasks[task_id] = async_task
        
        self._notify_task_event('task_started', task)
        return True
    
    def stop_task(self, task_id: str) -> bool:
        """åœæ­¢ä»»åŠ¡"""
        task = self.tasks.get(task_id)
        if not task:
            return False
        
        # å–æ¶ˆå¼‚æ­¥ä»»åŠ¡
        async_task = self.running_tasks.get(task_id)
        if async_task:
            async_task.cancel()
            self.running_tasks.pop(task_id, None)
        
        task.status = TaskStatus.CANCELLED
        self._notify_task_event('task_stopped', task)
        return True
    
    def get_task_status(self, task_id: str) -> str:
        """è·å–ä»»åŠ¡çŠ¶æ€"""
        task = self.tasks.get(task_id)
        return task.status.value if task else "not_found"
    
    def get_all_tasks(self) -> List[dict]:
        """è·å–æ‰€æœ‰ä»»åŠ¡"""
        return [
            {
                'id': task.id,
                'name': task.config.name,
                'type': task.config.type.value,
                'status': task.status.value,
                'progress': task.progress,
                'created_at': task.created_at.isoformat(),
                'started_at': task.started_at.isoformat() if task.started_at else None,
                'completed_at': task.completed_at.isoformat() if task.completed_at else None
            }
            for task in self.tasks.values()
        ]
    
    async def _execute_task(self, task: Task):
        """æ‰§è¡Œä»»åŠ¡"""
        try:
            runner = self.task_runners.get(task.config.type)
            if not runner:
                raise ValueError(f"No runner found for task type: {task.config.type}")
            
            # æ‰§è¡Œä»»åŠ¡
            await asyncio.wait_for(runner(task), timeout=task.config.timeout)
            
            task.status = TaskStatus.COMPLETED
            task.completed_at = datetime.now()
            task.progress = 1.0
            
        except asyncio.TimeoutError:
            task.status = TaskStatus.FAILED
            task.error_message = "Task timeout"
        except asyncio.CancelledError:
            task.status = TaskStatus.CANCELLED
        except Exception as e:
            task.status = TaskStatus.FAILED
            task.error_message = str(e)
            
            # é‡è¯•é€»è¾‘
            if task.retry_count < task.config.max_retries:
                task.retry_count += 1
                task.status = TaskStatus.CREATED
                await asyncio.sleep(5)  # ç­‰å¾…5ç§’åé‡è¯•
                await self._execute_task(task)
        finally:
            self.running_tasks.pop(task.id, None)
            self._notify_task_event('task_completed', task)
    
    async def _run_daily_mission(self, task: Task):
        """æ‰§è¡Œæ—¥å¸¸ä»»åŠ¡"""
        # æ¨¡æ‹Ÿæ—¥å¸¸ä»»åŠ¡æ‰§è¡Œ
        steps = [
            "æ£€æŸ¥æ¸¸æˆçŠ¶æ€",
            "è¿›å…¥ä»»åŠ¡ç•Œé¢",
            "é¢†å–æ—¥å¸¸ä»»åŠ¡",
            "æ‰§è¡Œä»»åŠ¡",
            "æäº¤ä»»åŠ¡"
        ]
        
        for i, step in enumerate(steps):
            logger.info(f"æ‰§è¡Œæ­¥éª¤: {step}")
            task.progress = (i + 1) / len(steps)
            await asyncio.sleep(2)  # æ¨¡æ‹Ÿæ‰§è¡Œæ—¶é—´
    
    async def _run_resource_farming(self, task: Task):
        """æ‰§è¡Œèµ„æºåˆ·å–ä»»åŠ¡"""
        # æ¨¡æ‹Ÿèµ„æºåˆ·å–
        target_count = task.config.parameters.get('target_count', 10)
        
        for i in range(target_count):
            logger.info(f"åˆ·å–èµ„æº {i+1}/{target_count}")
            task.progress = (i + 1) / target_count
            await asyncio.sleep(3)  # æ¨¡æ‹Ÿæ‰§è¡Œæ—¶é—´
    
    async def _run_battle_pass(self, task: Task):
        """æ‰§è¡Œæˆ˜ä»¤ä»»åŠ¡"""
        # æ¨¡æ‹Ÿæˆ˜ä»¤ä»»åŠ¡
        logger.info("æ‰§è¡Œæˆ˜ä»¤ä»»åŠ¡")
        await asyncio.sleep(5)
        task.progress = 1.0
    
    async def _run_custom_script(self, task: Task):
        """æ‰§è¡Œè‡ªå®šä¹‰è„šæœ¬"""
        # æ¨¡æ‹Ÿè‡ªå®šä¹‰è„šæœ¬æ‰§è¡Œ
        script_steps = task.config.parameters.get('steps', [])
        
        for i, step in enumerate(script_steps):
            logger.info(f"æ‰§è¡Œè„šæœ¬æ­¥éª¤: {step}")
            task.progress = (i + 1) / len(script_steps) if script_steps else 1.0
            await asyncio.sleep(1)
    
    def _notify_task_event(self, event_type: str, task: Task):
        """é€šçŸ¥ä»»åŠ¡äº‹ä»¶"""
        for callback in self.event_callbacks:
            try:
                callback(event_type, task)
            except Exception as e:
                logger.error(f"Task event callback error: {e}")
    
    def add_event_callback(self, callback: Callable):
        """æ·»åŠ äº‹ä»¶å›è°ƒ"""
        self.event_callbacks.append(callback)
```

#### 3.2.3 AutomationControllerå®Œæ•´å®ç°

**ç›®æ ‡**: å®ç°çœŸæ­£çš„è‡ªåŠ¨åŒ–æ§åˆ¶é€»è¾‘

**å®æ–½æ–¹æ¡ˆ**:
```python
# src/core/automation_controller.py
import asyncio
import time
from typing import List, Optional, Dict
from src.interfaces.automation_interface import IAutomationController
from src.core.game_detector import GameDetector
from src.core.task_manager import TaskManager, TaskType

class AutomationController(IAutomationController):
    def __init__(self):
        self.is_running = False
        self.game_detector = GameDetector()
        self.task_manager = TaskManager()
        self.automation_loop_task = None
        self.current_automation_tasks = []
        
        # å¯ç”¨çš„è‡ªåŠ¨åŒ–ä»»åŠ¡
        self.available_tasks = [
            "daily_missions",
            "resource_farming", 
            "battle_pass_tasks",
            "weekly_bosses",
            "simulated_universe"
        ]
        
        # è‡ªåŠ¨åŒ–é…ç½®
        self.automation_config = {
            'check_interval': 5,  # æ£€æŸ¥é—´éš”ï¼ˆç§’ï¼‰
            'max_continuous_failures': 3,  # æœ€å¤§è¿ç»­å¤±è´¥æ¬¡æ•°
            'auto_restart_game': True,  # è‡ªåŠ¨é‡å¯æ¸¸æˆ
            'task_timeout': 1800,  # ä»»åŠ¡è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰
        }
    
    def start_automation(self) -> bool:
        """å¯åŠ¨è‡ªåŠ¨åŒ–"""
        try:
            # æ£€æŸ¥æ¸¸æˆæ˜¯å¦è¿è¡Œ
            if not self.game_detector.is_game_running():
                logger.warning("æ¸¸æˆæœªè¿è¡Œï¼Œæ— æ³•å¯åŠ¨è‡ªåŠ¨åŒ–")
                return False
            
            # æ£€æµ‹æ¸¸æˆçª—å£
            game_window = self.game_detector.detect_game_window()
            if not game_window:
                logger.error("æ— æ³•æ£€æµ‹åˆ°æ¸¸æˆçª—å£")
                return False
            
            self.is_running = True
            
            # å¯åŠ¨è‡ªåŠ¨åŒ–å¾ªç¯
            self.automation_loop_task = asyncio.create_task(self._automation_loop())
            
            logger.info("è‡ªåŠ¨åŒ–å·²å¯åŠ¨")
            return True
            
        except Exception as e:
            logger.error(f"å¯åŠ¨è‡ªåŠ¨åŒ–å¤±è´¥: {e}")
            return False
    
    def stop_automation(self) -> bool:
        """åœæ­¢è‡ªåŠ¨åŒ–"""
        try:
            self.is_running = False
            
            # åœæ­¢è‡ªåŠ¨åŒ–å¾ªç¯
            if self.automation_loop_task:
                self.automation_loop_task.cancel()
                self.automation_loop_task = None
            
            # åœæ­¢æ‰€æœ‰è¿è¡Œä¸­çš„ä»»åŠ¡
            for task_id in self.current_automation_tasks:
                self.task_manager.stop_task(task_id)
            
            self.current_automation_tasks.clear()
            
            logger.info("è‡ªåŠ¨åŒ–å·²åœæ­¢")
            return True
            
        except Exception as e:
            logger.error(f"åœæ­¢è‡ªåŠ¨åŒ–å¤±è´¥: {e}")
            return False
    
    def get_automation_status(self) -> str:
        """è·å–è‡ªåŠ¨åŒ–çŠ¶æ€"""
        if self.is_running:
            return f"running (active_tasks: {len(self.current_automation_tasks)})"
        else:
            return "stopped"
    
    def get_available_tasks(self) -> List[str]:
        """è·å–å¯ç”¨ä»»åŠ¡åˆ—è¡¨"""
        return self.available_tasks.copy()
    
    async def _automation_loop(self):
        """è‡ªåŠ¨åŒ–ä¸»å¾ªç¯"""
        consecutive_failures = 0
        
        while self.is_running:
            try:
                # æ£€æŸ¥æ¸¸æˆçŠ¶æ€
                if not self.game_detector.is_game_running():
                    logger.warning("æ¸¸æˆå·²å…³é—­")
                    if self.automation_config['auto_restart_game']:
                        await self._handle_game_closed()
                    else:
                        break
                
                # æ£€æŸ¥å½“å‰æ¸¸æˆåœºæ™¯
                current_scene = await self._detect_current_scene()
                logger.debug(f"å½“å‰åœºæ™¯: {current_scene}")
                
                # æ ¹æ®åœºæ™¯æ‰§è¡Œç›¸åº”æ“ä½œ
                await self._handle_scene(current_scene)
                
                # æ£€æŸ¥å¹¶æ‰§è¡Œå¾…å¤„ç†ä»»åŠ¡
                await self._process_pending_tasks()
                
                # é‡ç½®å¤±è´¥è®¡æ•°
                consecutive_failures = 0
                
            except Exception as e:
                consecutive_failures += 1
                logger.error(f"è‡ªåŠ¨åŒ–å¾ªç¯é”™è¯¯ ({consecutive_failures}/{self.automation_config['max_continuous_failures']}): {e}")
                
                if consecutive_failures >= self.automation_config['max_continuous_failures']:
                    logger.error("è¿ç»­å¤±è´¥æ¬¡æ•°è¿‡å¤šï¼Œåœæ­¢è‡ªåŠ¨åŒ–")
                    break
            
            # ç­‰å¾…ä¸‹æ¬¡æ£€æŸ¥
            await asyncio.sleep(self.automation_config['check_interval'])
        
        # æ¸…ç†
        self.is_running = False
        logger.info("è‡ªåŠ¨åŒ–å¾ªç¯å·²ç»“æŸ")
    
    async def _detect_current_scene(self) -> str:
        """æ£€æµ‹å½“å‰æ¸¸æˆåœºæ™¯"""
        # æˆªå–æ¸¸æˆç”»é¢
        screenshot = self.game_detector.capture_screen()
        if not screenshot:
            return "unknown"
        
        # æ£€æµ‹å„ç§UIå…ƒç´ æ¥åˆ¤æ–­åœºæ™¯
        scenes = {
            "main_menu": "assets/templates/main_menu.png",
            "world_map": "assets/templates/world_map.png",
            "battle": "assets/templates/battle_ui.png",
            "mission_menu": "assets/templates/mission_menu.png",
            "inventory": "assets/templates/inventory.png"
        }
        
        for scene_name, template_path in scenes.items():
            result = self.game_detector.find_template(template_path, threshold=0.7)
            if result:
                return scene_name
        
        return "unknown"
    
    async def _handle_scene(self, scene: str):
        """å¤„ç†ç‰¹å®šåœºæ™¯"""
        if scene == "main_menu":
            await self._handle_main_menu()
        elif scene == "world_map":
            await self._handle_world_map()
        elif scene == "battle":
            await self._handle_battle()
        elif scene == "mission_menu":
            await self._handle_mission_menu()
        else:
            # æœªçŸ¥åœºæ™¯ï¼Œå°è¯•è¿”å›ä¸»ç•Œé¢
            await self._return_to_main_menu()
    
    async def _handle_main_menu(self):
        """å¤„ç†ä¸»èœå•åœºæ™¯"""
        # æ£€æŸ¥æ˜¯å¦æœ‰æ—¥å¸¸ä»»åŠ¡éœ€è¦å®Œæˆ
        if await self._should_do_daily_missions():
            await self._start_daily_missions()
    
    async def _handle_world_map(self):
        """å¤„ç†ä¸–ç•Œåœ°å›¾åœºæ™¯"""
        # æ£€æŸ¥æ˜¯å¦æœ‰èµ„æºç‚¹éœ€è¦æ”¶é›†
        if await self._should_collect_resources():
            await self._start_resource_collection()
    
    async def _handle_battle(self):
        """å¤„ç†æˆ˜æ–—åœºæ™¯"""
        # æˆ˜æ–—ä¸­ï¼Œç­‰å¾…æˆ˜æ–—ç»“æŸ
        logger.info("æ£€æµ‹åˆ°æˆ˜æ–—ä¸­ï¼Œç­‰å¾…æˆ˜æ–—ç»“æŸ")
        await asyncio.sleep(2)
    
    async def _handle_mission_menu(self):
        """å¤„ç†ä»»åŠ¡èœå•åœºæ™¯"""
        # æ£€æŸ¥å¹¶é¢†å–å¯ç”¨ä»»åŠ¡
        await self._claim_available_missions()
    
    async def _should_do_daily_missions(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦åº”è¯¥æ‰§è¡Œæ—¥å¸¸ä»»åŠ¡"""
        # æ£€æŸ¥æ—¥å¸¸ä»»åŠ¡æ˜¯å¦å·²å®Œæˆ
        # è¿™é‡Œå¯ä»¥é€šè¿‡UIæ£€æµ‹æˆ–é…ç½®æ–‡ä»¶æ¥åˆ¤æ–­
        return True  # ç®€åŒ–å®ç°
    
    async def _should_collect_resources(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦åº”è¯¥æ”¶é›†èµ„æº"""
        # æ£€æŸ¥èµ„æºæ”¶é›†é…ç½®
        return True  # ç®€åŒ–å®ç°
    
    async def _start_daily_missions(self):
        """å¯åŠ¨æ—¥å¸¸ä»»åŠ¡"""
        task_config = {
            'name': 'è‡ªåŠ¨æ—¥å¸¸ä»»åŠ¡',
            'type': TaskType.DAILY_MISSION.value,
            'parameters': {
                'auto_claim': True,
                'auto_complete': True
            }
        }
        
        task_id = self.task_manager.create_task(task_config)
        if self.task_manager.start_task(task_id):
            self.current_automation_tasks.append(task_id)
            logger.info(f"å·²å¯åŠ¨æ—¥å¸¸ä»»åŠ¡: {task_id}")
    
    async def _start_resource_collection(self):
        """å¯åŠ¨èµ„æºæ”¶é›†"""
        task_config = {
            'name': 'è‡ªåŠ¨èµ„æºæ”¶é›†',
            'type': TaskType.RESOURCE_FARMING.value,
            'parameters': {
                'target_count': 20,
                'resource_type': 'all'
            }
        }
        
        task_id = self.task_manager.create_task(task_config)
        if self.task_manager.start_task(task_id):
            self.current_automation_tasks.append(task_id)
            logger.info(f"å·²å¯åŠ¨èµ„æºæ”¶é›†: {task_id}")
    
    async def _claim_available_missions(self):
        """é¢†å–å¯ç”¨ä»»åŠ¡"""
        # æ£€æµ‹å¹¶ç‚¹å‡»ä»»åŠ¡é¢†å–æŒ‰é’®
        claim_button = self.game_detector.find_template("assets/templates/claim_button.png")
        if claim_button:
            # æ¨¡æ‹Ÿç‚¹å‡»
            await self._click_at_location(claim_button['location'])
            logger.info("å·²é¢†å–å¯ç”¨ä»»åŠ¡")
    
    async def _return_to_main_menu(self):
        """è¿”å›ä¸»èœå•"""
        # å°è¯•æŒ‰ESCé”®è¿”å›
        import keyboard
        keyboard.press_and_release('esc')
        await asyncio.sleep(1)
    
    async def _click_at_location(self, location: tuple):
        """åœ¨æŒ‡å®šä½ç½®ç‚¹å‡»"""
        import mouse
        mouse.move(location[0], location[1])
        mouse.click('left')
        await asyncio.sleep(0.5)
    
    async def _process_pending_tasks(self):
        """å¤„ç†å¾…å¤„ç†ä»»åŠ¡"""
        # æ¸…ç†å·²å®Œæˆçš„ä»»åŠ¡
        completed_tasks = []
        for task_id in self.current_automation_tasks:
            status = self.task_manager.get_task_status(task_id)
            if status in ['completed', 'failed', 'cancelled']:
                completed_tasks.append(task_id)
        
        for task_id in completed_tasks:
            self.current_automation_tasks.remove(task_id)
            logger.info(f"ä»»åŠ¡å·²å®Œæˆ: {task_id}")
    
    async def _handle_game_closed(self):
        """å¤„ç†æ¸¸æˆå…³é—­æƒ…å†µ"""
        logger.info("å°è¯•é‡æ–°å¯åŠ¨æ¸¸æˆ")
        # è¿™é‡Œå¯ä»¥æ·»åŠ é‡å¯æ¸¸æˆçš„é€»è¾‘
        # æš‚æ—¶åœæ­¢è‡ªåŠ¨åŒ–
        self.is_running = False
```

### 3.3 ç›‘æ§ç³»ç»Ÿå®Œå–„æ–¹æ¡ˆ

#### 3.3.1 HealthCheckerå®ç°

**ç›®æ ‡**: å®ç°çœŸæ­£çš„å¥åº·æ£€æŸ¥åŠŸèƒ½

**å®æ–½æ–¹æ¡ˆ**:
```python
# src/monitoring/health_checker.py
import asyncio
import time
from typing import Dict, List, Callable, Optional
from dataclasses import dataclass
from enum import Enum

class HealthStatus(Enum):
    HEALTHY = "healthy"
    UNHEALTHY = "unhealthy"
    UNKNOWN = "unknown"

@dataclass
class HealthCheckResult:
    component: str
    status: HealthStatus
    message: str
    response_time: float
    timestamp: float
    details: Dict = None

class HealthChecker:
    def __init__(self):
        self.is_running = False
        self.check_interval = 30  # 30ç§’æ£€æŸ¥ä¸€æ¬¡
        self.health_checks: Dict[str, Callable] = {}
        self.last_results: Dict[str, HealthCheckResult] = {}
        self.health_check_task = None
        self.callbacks: List[Callable] = []
    
    def register_health_check(self, component: str, check_func: Callable):
        """æ³¨å†Œå¥åº·æ£€æŸ¥å‡½æ•°"""
        self.health_checks[component] = check_func
    
    def start(self):
        """å¯åŠ¨å¥åº·æ£€æŸ¥"""
        if self.is_running:
            return
        
        self.is_running = True
        self.health_check_task = asyncio.create_task(self._health_check_loop())
        logger.info("å¥åº·æ£€æŸ¥å·²å¯åŠ¨")
    
    def stop(self):
        """åœæ­¢å¥åº·æ£€æŸ¥"""
        self.is_running = False
        if self.health_check_task:
            self.health_check_task.cancel()
            self.health_check_task = None
        logger.info("å¥åº·æ£€æŸ¥å·²åœæ­¢")
    
    async def _health_check_loop(self):
        """å¥åº·æ£€æŸ¥å¾ªç¯"""
        while self.is_running:
            try:
                await self._perform_health_checks()
                await asyncio.sleep(self.check_interval)
            except asyncio.CancelledError:
                break
            except Exception as e:
                logger.error(f"å¥åº·æ£€æŸ¥å¾ªç¯é”™è¯¯: {e}")
                await asyncio.sleep(5)
    
    async def _perform_health_checks(self):
        """æ‰§è¡Œæ‰€æœ‰å¥åº·æ£€æŸ¥"""
        results = []
        
        for component, check_func in self.health_checks.items():
            start_time = time.time()
            try:
                # æ‰§è¡Œå¥åº·æ£€æŸ¥
                if asyncio.iscoroutinefunction(check_func):
                    is_healthy, message, details = await check_func()
                else:
                    is_healthy, message, details = check_func()
                
                response_time = time.time() - start_time
                status = HealthStatus.HEALTHY if is_healthy else HealthStatus.UNHEALTHY
                
                result = HealthCheckResult(
                    component=component,
                    status=status,
                    message=message,
                    response_time=response_time,
                    timestamp=time.time(),
                    details=details or {}
                )
                
            except Exception as e:
                response_time = time.time() - start_time
                result = HealthCheckResult(
                    component=component,
                    status=HealthStatus.UNHEALTHY,
                    message=f"å¥åº·æ£€æŸ¥å¼‚å¸¸: {str(e)}",
                    response_time=response_time,
                    timestamp=time.time(),
                    details={'error': str(e)}
                )
            
            results.append(result)
            self.last_results[component] = result
        
        # é€šçŸ¥å›è°ƒ
        for callback in self.callbacks:
            try:
                callback(results)
            except Exception as e:
                logger.error(f"å¥åº·æ£€æŸ¥å›è°ƒé”™è¯¯: {e}")
    
    def get_health_status(self) -> Dict[str, HealthCheckResult]:
        """è·å–å¥åº·çŠ¶æ€"""
        return self.last_results.copy()
    
    def add_callback(self, callback: Callable):
        """æ·»åŠ å¥åº·æ£€æŸ¥å›è°ƒ"""
        self.callbacks.append(callback)

# å…·ä½“çš„å¥åº·æ£€æŸ¥å®ç°
class ComponentHealthChecks:
    def __init__(self, game_detector, task_manager, automation_controller):
        self.game_detector = game_detector
        self.task_manager = task_manager
        self.automation_controller = automation_controller
    
    async def check_game_detector(self) -> tuple:
        """æ£€æŸ¥æ¸¸æˆæ£€æµ‹å™¨å¥åº·çŠ¶æ€"""
        try:
            # æ£€æŸ¥æ¸¸æˆæ£€æµ‹å™¨æ˜¯å¦èƒ½æ­£å¸¸å·¥ä½œ
            is_running = self.game_detector.is_game_running()
            
            if is_running:
                # å°è¯•æ£€æµ‹æ¸¸æˆçª—å£
                window = self.game_detector.detect_game_window()
                if window:
                    return True, "æ¸¸æˆæ£€æµ‹å™¨æ­£å¸¸ï¼Œå·²æ£€æµ‹åˆ°æ¸¸æˆçª—å£", {
                        'game_running': True,
                        'window_detected': True,
                        'window_title': window.get('title', '')
                    }
                else:
                    return False, "æ¸¸æˆæ­£åœ¨è¿è¡Œä½†æ— æ³•æ£€æµ‹åˆ°çª—å£", {
                        'game_running': True,
                        'window_detected': False
                    }
            else:
                return True, "æ¸¸æˆæ£€æµ‹å™¨æ­£å¸¸ï¼Œæ¸¸æˆæœªè¿è¡Œ", {
                    'game_running': False,
                    'window_detected': False
                }
        except Exception as e:
            return False, f"æ¸¸æˆæ£€æµ‹å™¨å¼‚å¸¸: {str(e)}", {'error': str(e)}
    
    async def check_task_manager(self) -> tuple:
        """æ£€æŸ¥ä»»åŠ¡ç®¡ç†å™¨å¥åº·çŠ¶æ€"""
        try:
            # æ£€æŸ¥ä»»åŠ¡ç®¡ç†å™¨åŸºæœ¬åŠŸèƒ½
            tasks = self.task_manager.get_all_tasks()
            running_tasks = [t for t in tasks if t['status'] == 'running']
            
            return True, f"ä»»åŠ¡ç®¡ç†å™¨æ­£å¸¸ï¼Œå½“å‰æœ‰{len(tasks)}ä¸ªä»»åŠ¡ï¼Œ{len(running_tasks)}ä¸ªè¿è¡Œä¸­", {
                'total_tasks': len(tasks),
                'running_tasks': len(running_tasks),
                'task_manager_responsive': True
            }
        except Exception as e:
            return False, f"ä»»åŠ¡ç®¡ç†å™¨å¼‚å¸¸: {str(e)}", {'error': str(e)}
    
    async def check_automation_controller(self) -> tuple:
        """æ£€æŸ¥è‡ªåŠ¨åŒ–æ§åˆ¶å™¨å¥åº·çŠ¶æ€"""
        try:
            status = self.automation_controller.get_automation_status()
            available_tasks = self.automation_controller.get_available_tasks()
            
            return True, f"è‡ªåŠ¨åŒ–æ§åˆ¶å™¨æ­£å¸¸ï¼ŒçŠ¶æ€: {status}", {
                'status': status,
                'available_tasks_count': len(available_tasks),
                'controller_responsive': True
            }
        except Exception as e:
            return False, f"è‡ªåŠ¨åŒ–æ§åˆ¶å™¨å¼‚å¸¸: {str(e)}", {'error': str(e)}
```

#### 3.3.2 MetricsCollectorå®ç°

**ç›®æ ‡**: å®ç°çœŸæ­£çš„æŒ‡æ ‡æ”¶é›†åŠŸèƒ½

**å®æ–½æ–¹æ¡ˆ**:
```python
# src/monitoring/metrics_collector.py
import time
import asyncio
from typing import Dict, List, Any, Optional
from dataclasses import dataclass, field
from collections import defaultdict, deque
import json

@dataclass
class Metric:
    name: str
    value: float
    timestamp: float
    tags: Dict[str, str] = field(default_factory=dict)
    type: str = "gauge"  # gauge, counter, histogram

class MetricsCollector:
    def __init__(self):
        self.is_running = False
        self.metrics: Dict[str, deque] = defaultdict(lambda: deque(maxlen=1000))
        self.counters: Dict[str, float] = defaultdict(float)
        self.gauges: Dict[str, float] = {}
        self.collection_task = None
        self.collection_interval = 10  # 10ç§’æ”¶é›†ä¸€æ¬¡
        self.callbacks: List[callable] = []
    
    def start(self):
        """å¯åŠ¨æŒ‡æ ‡æ”¶é›†"""
        if self.is_running:
            return
        
        self.is_running = True
        self.collection_task = asyncio.create_task(self._collection_loop())
        logger.info("æŒ‡æ ‡æ”¶é›†å·²å¯åŠ¨")
    
    def stop(self):
        """åœæ­¢æŒ‡æ ‡æ”¶é›†"""
        self.is_running = False
        if self.collection_task:
            self.collection_task.cancel()
            self.collection_task = None
        logger.info("æŒ‡æ ‡æ”¶é›†å·²åœæ­¢")
    
    def record_gauge(self, name: str, value: float, tags: Dict[str, str] = None):
        """è®°å½•ä»ªè¡¨ç›˜æŒ‡æ ‡"""
        metric = Metric(
            name=name,
            value=value,
            timestamp=time.time(),
            tags=tags or {},
            type="gauge"
        )
        
        self.gauges[name] = value
        self.metrics[name].append(metric)
    
    def increment_counter(self, name: str, value: float = 1.0, tags: Dict[str, str] = None):
        """å¢åŠ è®¡æ•°å™¨"""
        self.counters[name] += value
        
        metric = Metric(
            name=name,
            value=self.counters[name],
            timestamp=time.time(),
            tags=tags or {},
            type="counter"
        )
        
        self.metrics[name].append(metric)
    
    def record_histogram(self, name: str, value: float, tags: Dict[str, str] = None):
        """è®°å½•ç›´æ–¹å›¾æŒ‡æ ‡"""
        metric = Metric(
            name=name,
            value=value,
            timestamp=time.time(),
            tags=tags or {},
            type="histogram"
        )
        
        self.metrics[name].append(metric)
    
    async def _collection_loop(self):
        """æŒ‡æ ‡æ”¶é›†å¾ªç¯"""
        while self.is_running:
            try:
                await self._collect_system_metrics()
                await asyncio.sleep(self.collection_interval)
            except asyncio.CancelledError:
                break
            except Exception as e:
                logger.error(f"æŒ‡æ ‡æ”¶é›†é”™è¯¯: {e}")
                await asyncio.sleep(5)
    
    async def _collect_system_metrics(self):
        """æ”¶é›†ç³»ç»ŸæŒ‡æ ‡"""
        import psutil
        
        # CPUä½¿ç”¨ç‡
        cpu_percent = psutil.cpu_percent(interval=1)
        self.record_gauge("system.cpu.usage", cpu_percent, {"unit": "percent"})
        
        # å†…å­˜ä½¿ç”¨ç‡
        memory = psutil.virtual_memory()
        self.record_gauge("system.memory.usage", memory.percent, {"unit": "percent"})
        self.record_gauge("system.memory.available", memory.available, {"unit": "bytes"})
        
        # ç£ç›˜ä½¿ç”¨ç‡
        disk = psutil.disk_usage('/')
        self.record_gauge("system.disk.usage", (disk.used / disk.total) * 100, {"unit": "percent"})
        
        # è¿›ç¨‹ä¿¡æ¯
        process = psutil.Process()
        self.record_gauge("process.cpu.usage", process.cpu_percent(), {"unit": "percent"})
        self.record_gauge("process.memory.usage", process.memory_info().rss, {"unit": "bytes"})
    
    def get_metrics(self, name: str = None, limit: int = 100) -> List[Metric]:
        """è·å–æŒ‡æ ‡æ•°æ®"""
        if name:
            return list(self.metrics[name])[-limit:]
        
        all_metrics = []
        for metric_name, metric_list in self.metrics.items():
            all_metrics.extend(list(metric_list)[-limit:])
        
        return sorted(all_metrics, key=lambda x: x.timestamp)[-limit:]
    
    def get_current_values(self) -> Dict[str, float]:
        """è·å–å½“å‰æŒ‡æ ‡å€¼"""
        current_values = {}
        current_values.update(self.gauges)
        current_values.update(self.counters)
        return current_values
    
    def export_metrics(self, format: str = "json") -> str:
        """å¯¼å‡ºæŒ‡æ ‡æ•°æ®"""
        if format == "json":
            data = {
                'timestamp': time.time(),
                'gauges': self.gauges,
                'counters': dict(self.counters),
                'recent_metrics': [
                    {
                        'name': m.name,
                        'value': m.value,
                        'timestamp': m.timestamp,
                        'tags': m.tags,
                        'type': m.type
                    }
                    for m in self.get_metrics(limit=50)
                ]
            }
            return json.dumps(data, indent=2)
        
        return ""
    
    def add_callback(self, callback: callable):
        """æ·»åŠ æŒ‡æ ‡å›è°ƒ"""
        self.callbacks.append(callback)
```

### 3.4 é…ç½®ç®¡ç†å®Œå–„æ–¹æ¡ˆ

#### 3.4.1 å®Œæ•´é…ç½®ç»“æ„

**ç›®æ ‡**: å»ºç«‹å®Œæ•´çš„é…ç½®ç®¡ç†ä½“ç³»

**å®æ–½æ–¹æ¡ˆ**:
```python
# config/default_config.json
{
  "game": {
    "window_title": "å´©åï¼šæ˜Ÿç©¹é“é“",
    "process_name": "StarRail.exe",
    "detection_interval": 5,
    "screenshot_quality": 90,
    "template_threshold": 0.8
  },
  "automation": {
    "enabled": true,
    "check_interval": 5,
    "max_continuous_failures": 3,
    "auto_restart_game": true,
    "task_timeout": 1800,
    "daily_missions": {
      "enabled": true,
      "auto_claim": true,
      "auto_complete": true,
      "priority": 1
    },
    "resource_farming": {
      "enabled": true,
      "target_count": 20,
      "resource_types": ["all"],
      "priority": 2
    },
    "battle_pass": {
      "enabled": true,
      "auto_claim_rewards": true,
      "priority": 3
    }
  },
  "monitoring": {
    "health_check_interval": 30,
    "metrics_collection_interval": 10,
    "log_level": "INFO",
    "enable_performance_monitoring": true
  },
  "ui": {
    "theme": "dark",
    "language": "zh_CN",
    "auto_save_settings": true,
    "window_size": [1200, 800],
    "window_position": [100, 100]
  },
  "database": {
    "path": "data/xingtie.db",
    "backup_enabled": true,
    "backup_interval": 86400,
    "max_backups": 7
  }
}
```

## 4. å®æ–½è®¡åˆ’

### 4.1 ç¬¬ä¸€é˜¶æ®µï¼šæ¥å£è§„èŒƒåŒ–ï¼ˆ1-2å‘¨ï¼‰

**ç›®æ ‡**: è§£å†³æ¥å£ä¸åŒ¹é…é—®é¢˜ï¼Œå»ºç«‹ç»Ÿä¸€çš„æ¥å£è§„èŒƒ

**ä¸»è¦ä»»åŠ¡**:
1. åˆ›å»ºç»Ÿä¸€çš„æ¥å£å®šä¹‰æ–‡ä»¶
2. æ›´æ–°æ‰€æœ‰å®ç°ç±»ä»¥ç¬¦åˆæ¥å£è§„èŒƒ
3. å»ºç«‹æ¥å£å…¼å®¹æ€§æµ‹è¯•
4. ä¿®å¤ç°æœ‰çš„æ–¹æ³•è°ƒç”¨é”™è¯¯

**é¢„æœŸæˆæœ**:
- æ‰€æœ‰æ¥å£è°ƒç”¨éƒ½æœ‰å¯¹åº”çš„å®ç°
- æ¶ˆé™¤`AttributeError`é”™è¯¯
- å»ºç«‹æ¥å£å˜æ›´ç®¡ç†æµç¨‹

### 4.2 ç¬¬äºŒé˜¶æ®µï¼šæ ¸å¿ƒåŠŸèƒ½å®ç°ï¼ˆ3-4å‘¨ï¼‰

**ç›®æ ‡**: å®ç°çœŸæ­£å¯ç”¨çš„æ ¸å¿ƒä¸šåŠ¡åŠŸèƒ½

**ä¸»è¦ä»»åŠ¡**:
1. **GameDetectorå®Œæ•´å®ç°**
   - å®ç°çœŸå®çš„æ¸¸æˆè¿›ç¨‹æ£€æµ‹
   - å®Œå–„æ¸¸æˆçª—å£è¯†åˆ«å’Œæˆªå›¾åŠŸèƒ½
   - å®ç°æ¨¡æ¿åŒ¹é…å’ŒUIå…ƒç´ è¯†åˆ«

2. **TaskManagerå®Œæ•´å®ç°**
   - å®ç°å¼‚æ­¥ä»»åŠ¡æ‰§è¡Œæ¡†æ¶
   - æ·»åŠ å…·ä½“çš„ä»»åŠ¡æ‰§è¡Œé€»è¾‘
   - å®ç°ä»»åŠ¡è°ƒåº¦å’Œä¾èµ–ç®¡ç†

3. **AutomationControllerå®Œæ•´å®ç°**
   - å®ç°è‡ªåŠ¨åŒ–ä¸»å¾ªç¯
   - æ·»åŠ åœºæ™¯è¯†åˆ«å’Œå¤„ç†é€»è¾‘
   - å®ç°å…·ä½“çš„æ¸¸æˆè‡ªåŠ¨åŒ–æ“ä½œ

**é¢„æœŸæˆæœ**:
- æ¸¸æˆæ£€æµ‹åŠŸèƒ½æ­£å¸¸å·¥ä½œ
- ä»»åŠ¡ç®¡ç†ç³»ç»Ÿèƒ½å¤Ÿæ‰§è¡Œå®é™…ä»»åŠ¡
- è‡ªåŠ¨åŒ–æ§åˆ¶å™¨èƒ½å¤Ÿè¿›è¡ŒåŸºæœ¬çš„æ¸¸æˆè‡ªåŠ¨åŒ–

### 4.3 ç¬¬ä¸‰é˜¶æ®µï¼šç›‘æ§ç³»ç»Ÿå®Œå–„ï¼ˆ1-2å‘¨ï¼‰

**ç›®æ ‡**: å»ºç«‹å®Œæ•´çš„ç›‘æ§å’ŒæŒ‡æ ‡æ”¶é›†ä½“ç³»

**ä¸»è¦ä»»åŠ¡**:
1. å®ç°çœŸæ­£çš„å¥åº·æ£€æŸ¥åŠŸèƒ½
2. å®Œå–„æŒ‡æ ‡æ”¶é›†ç³»ç»Ÿ
3. å»ºç«‹å‘Šè­¦æœºåˆ¶
4. å®ç°æ€§èƒ½ç›‘æ§

**é¢„æœŸæˆæœ**:
- å¥åº·æ£€æŸ¥èƒ½å¤Ÿå‡†ç¡®åæ˜ ç³»ç»ŸçŠ¶æ€
- æŒ‡æ ‡æ”¶é›†ç³»ç»Ÿæ­£å¸¸å·¥ä½œ
- ç›‘æ§æ•°æ®å¯è§†åŒ–

### 4.4 ç¬¬å››é˜¶æ®µï¼šé…ç½®å’Œæ•°æ®å®Œå–„ï¼ˆ1å‘¨ï¼‰

**ç›®æ ‡**: å®Œå–„é…ç½®ç®¡ç†å’Œæ•°æ®æ¨¡å‹

**ä¸»è¦ä»»åŠ¡**:
1. å»ºç«‹å®Œæ•´çš„é…ç½®æ–‡ä»¶ç»“æ„
2. å®Œå–„æ•°æ®åº“è¡¨ç»“æ„
3. å®ç°é…ç½®çƒ­æ›´æ–°
4. æ·»åŠ æ•°æ®å¤‡ä»½æœºåˆ¶

**é¢„æœŸæˆæœ**:
- é…ç½®ç®¡ç†ä½“ç³»å®Œæ•´
- æ•°æ®æ¨¡å‹æ”¯æŒæ‰€æœ‰ä¸šåŠ¡éœ€æ±‚
- ç³»ç»Ÿå¯é…ç½®æ€§å¼º

### 4.5 ç¬¬äº”é˜¶æ®µï¼šæµ‹è¯•å’Œä¼˜åŒ–ï¼ˆ1-2å‘¨ï¼‰

**ç›®æ ‡**: å…¨é¢æµ‹è¯•å’Œæ€§èƒ½ä¼˜åŒ–

**ä¸»è¦ä»»åŠ¡**:
1. ç¼–å†™å®Œæ•´çš„å•å…ƒæµ‹è¯•
2. è¿›è¡Œé›†æˆæµ‹è¯•
3. æ€§èƒ½æµ‹è¯•å’Œä¼˜åŒ–
4. ç”¨æˆ·ä½“éªŒä¼˜åŒ–

**é¢„æœŸæˆæœ**:
- ç³»ç»Ÿç¨³å®šå¯é 
- æ€§èƒ½æ»¡è¶³è¦æ±‚
- ç”¨æˆ·ä½“éªŒè‰¯å¥½

## 5. é£é™©è¯„ä¼°å’Œç¼“è§£æªæ–½

### 5.1 æŠ€æœ¯é£é™©

**é£é™©1**: æ¸¸æˆæ£€æµ‹æŠ€æœ¯å¤æ‚æ€§
- **å½±å“**: å¯èƒ½æ— æ³•å‡†ç¡®è¯†åˆ«æ¸¸æˆçŠ¶æ€
- **ç¼“è§£æªæ–½**: é‡‡ç”¨å¤šç§æ£€æµ‹æ–¹æ³•ç»“åˆï¼Œå»ºç«‹æ¨¡æ¿åº“

**é£é™©2**: å¼‚æ­¥ä»»åŠ¡ç®¡ç†å¤æ‚æ€§
- **å½±å“**: ä»»åŠ¡è°ƒåº¦å¯èƒ½å‡ºç°æ­»é”æˆ–èµ„æºç«äº‰
- **ç¼“è§£æªæ–½**: ä½¿ç”¨æˆç†Ÿçš„å¼‚æ­¥æ¡†æ¶ï¼Œå……åˆ†æµ‹è¯•

**é£é™©3**: æ€§èƒ½é—®é¢˜
- **å½±å“**: ç³»ç»Ÿå“åº”æ…¢ï¼Œå½±å“ç”¨æˆ·ä½“éªŒ
- **ç¼“è§£æªæ–½**: æ€§èƒ½ç›‘æ§ï¼ŒåŠæ—¶ä¼˜åŒ–çƒ­ç‚¹ä»£ç 

### 5.2 ä¸šåŠ¡é£é™©

**é£é™©1**: æ¸¸æˆæ›´æ–°å¯¼è‡´åŠŸèƒ½å¤±æ•ˆ
- **å½±å“**: è‡ªåŠ¨åŒ–åŠŸèƒ½å¯èƒ½å¤±æ•ˆ
- **ç¼“è§£æªæ–½**: å»ºç«‹æ¨¡æ¿æ›´æ–°æœºåˆ¶ï¼Œå¿«é€Ÿé€‚é…

**é£é™©2**: ç”¨æˆ·éœ€æ±‚å˜åŒ–
- **å½±å“**: åŠŸèƒ½ä¸ç¬¦åˆç”¨æˆ·æœŸæœ›
- **ç¼“è§£æªæ–½**: å»ºç«‹ç”¨æˆ·åé¦ˆæœºåˆ¶ï¼Œå¿«é€Ÿè¿­ä»£

## 6. æˆåŠŸæ ‡å‡†

### 6.1 åŠŸèƒ½æ ‡å‡†
- [ ] æ¸¸æˆæ£€æµ‹åŠŸèƒ½æ­£å¸¸å·¥ä½œï¼Œå‡†ç¡®ç‡>95%
- [ ] ä»»åŠ¡ç®¡ç†ç³»ç»Ÿèƒ½å¤Ÿç¨³å®šæ‰§è¡Œå„ç±»ä»»åŠ¡
- [ ] è‡ªåŠ¨åŒ–æ§åˆ¶å™¨èƒ½å¤Ÿè¿›è¡ŒåŸºæœ¬çš„æ¸¸æˆè‡ªåŠ¨åŒ–æ“ä½œ
- [ ] ç›‘æ§ç³»ç»Ÿèƒ½å¤Ÿå‡†ç¡®åæ˜ ç³»ç»Ÿå¥åº·çŠ¶æ€
- [ ] ç”¨æˆ·ç•Œé¢å“åº”æµç•…ï¼Œæ“ä½œç®€å•

### 6.2 æ€§èƒ½æ ‡å‡†
- [ ] ç³»ç»Ÿå¯åŠ¨æ—¶é—´<10ç§’
- [ ] æ¸¸æˆæ£€æµ‹å“åº”æ—¶é—´<2ç§’
- [ ] ä»»åŠ¡æ‰§è¡ŒæˆåŠŸç‡>90%
- [ ] å†…å­˜ä½¿ç”¨<500MB
- [ ] CPUä½¿ç”¨ç‡<20%ï¼ˆç©ºé—²æ—¶ï¼‰

### 6.3 ç¨³å®šæ€§æ ‡å‡†
- [ ] è¿ç»­è¿è¡Œ24å°æ—¶æ— å´©æºƒ
- [ ] é”™è¯¯æ¢å¤æœºåˆ¶æœ‰æ•ˆ
- [ ] æ—¥å¿—è®°å½•å®Œæ•´ï¼Œä¾¿äºé—®é¢˜æ’æŸ¥

## 7. æ€»ç»“

æœ¬æ–‡æ¡£è¯¦ç»†åˆ†æäº†xingtieé¡¹ç›®å½“å‰å­˜åœ¨çš„é—®é¢˜ï¼Œå¹¶æä¾›äº†å®Œæ•´çš„è§£å†³æ–¹æ¡ˆã€‚ä¸»è¦é—®é¢˜é›†ä¸­åœ¨æ¥å£ä¸åŒ¹é…ã€æ ¸å¿ƒåŠŸèƒ½ç¼ºå¤±ã€ç›‘æ§ç³»ç»Ÿä¸å®Œå–„ç­‰æ–¹é¢ã€‚

é€šè¿‡åˆ†é˜¶æ®µçš„å®æ–½è®¡åˆ’ï¼Œé¢„è®¡åœ¨8-12å‘¨å†…èƒ½å¤Ÿå®Œå…¨è§£å†³è¿™äº›é—®é¢˜ï¼Œä½¿é¡¹ç›®å…·å¤‡çœŸæ­£çš„å®ç”¨ä»·å€¼ã€‚å…³é”®æ˜¯è¦ä¸¥æ ¼æŒ‰ç…§æ¥å£è§„èŒƒè¿›è¡Œå¼€å‘ï¼Œç¡®ä¿å„ç»„ä»¶ä¹‹é—´çš„å…¼å®¹æ€§ï¼ŒåŒæ—¶å»ºç«‹å®Œå–„çš„æµ‹è¯•å’Œç›‘æ§ä½“ç³»ã€‚

**ä¸‹ä¸€æ­¥è¡ŒåŠ¨**:
1. ç«‹å³å¼€å§‹ç¬¬ä¸€é˜¶æ®µçš„æ¥å£è§„èŒƒåŒ–å·¥ä½œ
2. å»ºç«‹é¡¹ç›®ç®¡ç†å’Œè¿›åº¦è·Ÿè¸ªæœºåˆ¶
3. ç»„ç»‡æŠ€æœ¯è¯„å®¡ï¼Œç¡®ä¿æ–¹æ¡ˆå¯è¡Œæ€§
4. å»ºç«‹æŒç»­é›†æˆå’Œéƒ¨ç½²æµç¨‹

åªæœ‰é€šè¿‡ç³»ç»Ÿæ€§çš„é‡æ„å’Œå®Œå–„ï¼Œxingtieé¡¹ç›®æ‰èƒ½ä»å½“å‰çš„"ç©ºæ¶å­"çŠ¶æ€è½¬å˜ä¸ºçœŸæ­£æœ‰ç”¨çš„è‡ªåŠ¨åŒ–å·¥å…·ã€‚